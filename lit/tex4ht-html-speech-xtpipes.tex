% $Id: tex4ht-html-speech-xtpipes.tex 65 2010-11-17 19:16:45Z karl $
% htlatex tex4ht-html-speech-xtpipes "html,next,3" "" "-d./"
%
% Copyright (C) 2009-2010 TeX Users Group
% Copyright (C) 2006-2009 Eitan M. Gurari
% Released under LPPL 1.3c+.
% See tex4ht-cpright.tex for license text.

\documentclass{article}
    \Configure{ProTex}{log,<<<>>>,title,list,`,[[]]}
\begin{document}

\input{common}
\input{tex4ht-cpright}

%%%%%%%%%%%%%%%%%%
\part{Script for xtpipes}
%%%%%%%%%%%%%%%%%%


%%%%%%%%%%%%%%%%%%
\section{Outline}
%%%%%%%%%%%%%%%%%%



\AtEndDocument{\OutputCodE\<htspk.4xt\>}


\Needs{"xmllint --valid --noout htspk.4xt"} 


\<htspk.4xt\><<<
<?xml version="1.0" encoding="UTF-8" ?>
<!DOCTYPE xtpipes SYSTEM "xtpipes.dtd" >
<!-- htspk.4xt (`version), generated from `jobname.tex
     Copyright (C) 2009-2010 TeX Users Group
     Copyright (C) `CopyYear.2002. Eitan M. Gurari
`<TeX4ht copyright`> -->
<xtpipes>
   <sax content-handler="xtpipes.util.ScriptsManager"
        lexical-handler="xtpipes.util.ScriptsManagerLH" >
     `<non short tag br elements`>     
     `<undo empty scripts`> 
     `<span frac elements`>
     `<short cut modifiers`>
     `<over and under scripts`>
     `<bold math`>
     `<capital math letters`>
     `<remove multline eqnum cell`> 
     `<inline math`>
     `<display math`>
     `<measure tables`>
     `<remove empty split entries`>
     `<boundaries on theorems`>
   </sax>
</xtpipes>
>>>



\<inline math\><<<
<script element="span::inline-math" >
  `<compress numeric subscripts`>
  `<set levels for hyper complex fracs`>
  `<set levels for sub and sup scripts`>
  `<set levels for roots`>
  <set name="inline-math" >
     `<open xslt script`>
     `<shared display and inline math 1`>
     `<eliminate inline math narrative`>
     `<close xslt script`>
  </set>
  <xslt name="." xml="." xsl="inline-math" />
  <set name="inline-math-2" >
     `<open xslt script`>
     `<shared display and inline math 2`>
     `<eliminate inline math narrative 2`>
     `<close xslt script`>
  </set>
  <xslt name="." xml="." xsl="inline-math-2" />
  `<set empty elements for the w3 browser`>
</script> 
>>>




\<display math\><<<
<script element="div::display-math" >
  `<compress numeric subscripts`>
  `<set levels for hyper complex fracs`>
  `<set levels for sub and sup scripts`>
  `<set levels for roots`>
  <set name="display-math" >
     `<open xslt script`>
     `<shared display and inline math 1`>
     `<close xslt script`>
  </set>
  <xslt name="." xml="." xsl="display-math" />
  <set name="display-math-2" >
     `<open xslt script`>
     `<shared display and inline math 2`>
     `<close xslt script`>
  </set>
  <xslt name="." xml="." xsl="display-math-2" />
  `<set empty elements for the w3 browser`>
</script> 
>>>

\<shared display and inline math 1\><<<
`<get content template`>
`<eliminate baseline script marks`> 
`<fraction 'and' prefix`> 
`<'minus' into 'negative'`> 
`<compress limit script`>
`<remove scrip indicators from primes`> 
>>>


\<shared display and inline math 2\><<<
`<get content template`>
`<replace nested baseline script marks`>
`<insert pre mi spaces`>
`<eliminate begin script marks`> 
>>>


\marginpar{Can dom be prevented from creating an xml declaration in
  the output? The xslt part is there just to remove the undesirable
  declaration.}


\<remove xml declaration\><<<
<set name="rmXmlDecl" >
  `<open xslt script`>
  `<close xslt script`>
</set>
<xslt name="." xml="." xsl="rmXmlDecl" />
>>>







\AtEndDocument{\OutputCodE\<HtSpk.java\>}

\Needs{"
    javac HtSpk.java      -d /home/4/gurari/xtpipes.dir/. 
"}

\<HtSpk.java\><<<
package tex4ht;
/* HtSpk.java (`version), generated from `jobname.tex
   Copyright (C) 2009-2010 TeX Users Group
   Copyright (C) `CopyYear.2006. Eitan M. Gurari
`<TeX4ht copyright`> */
import org.w3c.dom.*;
public class HtSpk {
  `<static void fracLevel(dom)`>
  `<static void scriptLevel(dom)`>
  `<static void rootLevel(dom)`>
}
>>>


%%%%%%%%%%%%%%%%%%
\section{Line Break Elements}
%%%%%%%%%%%%%%%%%%

Avoid short versions \verb+<br />+.

\<non short tag br elements\><<<
<script element="br" >
  <set name="br" >
    <![CDATA[ 
       <xsl:stylesheet version="1.0"
          xmlns:xsl="http://www.w3.org/1999/XSL/Transform"
       >
          <xsl:output omit-xml-declaration = "yes" />
          <xsl:template match="br" >
            <xsl:copy>
              <xsl:apply-templates select="@*" />
              <xsl:comment>`<comment`></xsl:comment>
            </xsl:copy>
          </xsl:template> 
          <xsl:template match="*|@*|text()|comment()" >
            <xsl:copy>
              <xsl:apply-templates select="*|@*|text()|comment()" />
            </xsl:copy>
          </xsl:template>
       </xsl:stylesheet> 
    ]]>
  </set>
  <xslt name="." xml="." xsl="br" />
</script> 
>>>

%%%%%%%%%%%%%%%%%%
\section{Capital Letters in Math}
%%%%%%%%%%%%%%%%%%

\<capital math letters\><<<
<script element="span::mi" >
  <set name="math-cap" >
     `<open xslt script`>
     `<span.mi cap letters`> 
     `<close xslt script`>
  </set>
  <xslt name="." xml="." xsl="math-cap" />
</script> 
>>>

%                     (translate(.,'abcdefghijklmnopqrstuvwxyz',
%                                  'ABCDEFGHIJKLMNOPQRSTUVWXYZ') = . )
%                    and

\<span.mi cap letters\><<<
<xsl:template match="span[ @class = 'mi' ]" >
  <xsl:copy>
    <xsl:apply-templates select="@*" />
      <xsl:if test=" string-length(.) = 1 " >      
         <xsl:if test="
                     (translate(.,'ABCDEFGHIJKLMNOPQRSTUVWXYZ',
                                  '') = '' )
                  " >      
            <span class="capital-description" 
                  title="speech-extra" >
               <xsl:text> capital </xsl:text>
            </span>
         </xsl:if>      
      </xsl:if>      
    <xsl:apply-templates select="*|text()|comment()" />
  </xsl:copy>
</xsl:template> 
>>>

%%%%%%%%%%%%%%%%%%
\section{Superscripts and Subscripts}
%%%%%%%%%%%%%%%%%%

%%%%%%%%%%%%%
\subsection{Insert Sub-Levels Info}
%%%%%%%%%%%%%




\<set levels for sub and sup scripts\><<<
<dom name="." xml="." method="scriptLevel" class="tex4ht.HtSpk" />
`<remove xml declaration`>
>>>



\<static void scriptLevel(dom)\><<<
public static void scriptLevel(Node dom) {
   setScriptLevel(dom.getFirstChild(), "");
}
private static void setScriptLevel(Node node, String prefix) {
  String clName = null;
  if (node.hasChildNodes()) {
    if (node.hasAttributes()) {
      Node cl = node.getAttributes().getNamedItem("class");
      if (cl != null) {
        clName = cl.getNodeValue();
        if( clName.equals("mrow-sub")
            ||
            clName.equals("mrow-super")
        ){
          `<append script prefix`>
        } else if( 
           clName.equals("msqrt")
        ){  prefix = ""; }
    } }
    `<script invoke children`>
} }
>>>

\<script invoke children\><<<
NodeList children = node.getChildNodes();
for (int i = 0; i < children.getLength(); i++) {
   Node child = children.item(i);
   if (child.getNodeType() == Node.ELEMENT_NODE) {
      setScriptLevel(child, prefix);
}  }
>>>

\<append script prefix\><<<
if( !prefix.equals("") ){
  `<use current script prefix`>
}
if( clName.equals( "mrow-sub" ) ){ prefix += " sub "; }
else
if( clName.equals( "mrow-super" ) ){ prefix += " super "; }
>>>


\<use current script prefix\><<<
Node child = node.getFirstChild();
if( (child.getNodeType() == Node.ELEMENT_NODE) 
    &&
    child.hasAttributes()
){
   Node cls = child.getAttributes().getNamedItem("class");
   if (cls != null) {
      String clsName = cls.getNodeValue();
      if ( clsName.equals("begin-script")
           ||
           clsName.equals("mid-script")
      ) {
         child = child.getFirstChild();
         String s = child.getNodeValue();
         ((org.w3c.dom.Text) child).setData( prefix + s );
}  }  }
>>>
 


%%%%%%%%%%%%%
\subsection{Eliminate  End Script Marks}
%%%%%%%%%%%%%


The following takes care of end-scripts that semantically can be
merged into other end markers.

\<eliminate baseline script marks\><<<
<xsl:template match="span[
   (@class = 'end-script')
   and
   ancestor::* [ following-sibling::* [
                         not( @class = 'content-less' )
                      ] 
               ][1]
           / following-sibling::* [
                         not( @class = 'content-less' )
                     ][1] 
           / self::*
    [
       (@class = 'end-math') 
       or
       (@class = 'end-script') 
       or
       (@class = 'end-root') 
       or
       (@class = 'end-stack') 
       or
       (@class = 'mid-stack') 
       or
       (@class = 'end-array') 
       or
       (@class = 'tr') 
       or
       (@title = 'implicit-baseline') 
    ]
]"  >
</xsl:template> 
>>>



%%%%%%%%%%%%%
\subsection{Replace Nested Baseline Script Marks}
%%%%%%%%%%%%%


\<replace nested baseline script marks\><<<
<xsl:template match="span[
     (@class = 'end-script')
   and
     ancestor::*[ preceding-sibling::* [
       ((@class = 'begin-script') or (@class = 'mid-script')) ]]
`%   and
     ( normalize-space(.) = 'baseline' )     REMOVE `%
]" >
  <xsl:copy>
     <xsl:apply-templates select="*|@*|comment()" />
     <xsl:value-of select="
            ancestor::*[ preceding-sibling::* [
                           ((@class = 'begin-script') or 
                            (@class = 'mid-script'))     ]]  [1]
            / preceding-sibling::* [
                           ((@class = 'begin-script') or 
                            (@class = 'mid-script'))  ][1]
      " />
  </xsl:copy>
</xsl:template>   
>>>


%%%%%%%%%%%%%
\subsection{Eliminate  Begin Script Marks}
%%%%%%%%%%%%%



\<eliminate begin script marks\><<<
<xsl:template match="span[
     (@class = 'begin-script')
   and
     following-sibling::* [1] / child::*[  
       (position() = 1)
       and 
       (@class = 'mrow-base')
       and
       ( normalize-space(.) = '' )
     ]
]"  >
</xsl:template> 
>>>



%%%%%%%%%%%%%
\subsection{Undo Empty Scripts}
%%%%%%%%%%%%%




\<undo empty scripts\><<<
<script element="span::msup" >
   <set name="m-sub-sup" >
     `<open xslt script`>
     `<undo if empty su`> 
     `<close xslt script`>
   </set>
   <xslt name="." xml="." xsl="m-sub-sup" />
   `<superscript 2 and 3 into verbose`>
</script> 
<script element="span::msub" >
  `<sub sup script`>
</script> 
<script element="span::msubsup" >
  `<subsup prime`>
  `<sub sup script`>
  `<sub superscript 2 and 3 into verbose`>
</script> 
>>>

\<sub sup script\><<<
<set name="m-sub-sup" >
  `<open xslt script`>
  `<undo if empty su`> 
  `<close xslt script`>
</set>
<xslt name="." xml="." xsl="m-sub-sup" />
>>>

\<undo if empty su\><<<
<xsl:template match="span[
    ((@class = 'msup') or (@class = 'msub')
                       or (@class = 'msubsup'))
  and
    not(
      child::span[ (@class = 'mrow-sub') ] 
        / child::span[ (@class != 'begin-script')
                       and
                       (@class != 'end-script')
                       and
                       (@class != 'mid-script')
                     ]
    )
  and
    not(
      child::span[ (@class = 'mrow-super') ] 
        / child::span[ (@class != 'begin-script')
                       and
                       (@class != 'end-script')
                       and
                       (@class != 'mid-script')
                     ]
    )
]" >
   <xsl:apply-templates select="child::span[ 
                          @class = 'mrow-base' ]/*" />
</xsl:template> 
>>>



\begin{verbatim}
<span class="msup">
   <span class="mrow-base">
     .........
   </span>
   <span class="mrow-super">
     <span class="begin-script"> superscript </span>
     <span class="end-script"> baseline </span>
   </span>
</span>
\end{verbatim}




%%%%%%%%%%%%%
\subsection{Squared}
%%%%%%%%%%%%%

\<superscript 2 and 3 into verbose\><<<
<set name="m-sup-2-3" >
  `<open xslt script`>
  `<superscript into squared abd cube`> 
  `<close xslt script`>
</set>
<xslt name="." xml="." xsl="m-sup-2-3" />
>>>

\<superscript into squared abd cube\><<<
<xsl:template match="span[
    (@class = 'msup') 
  and
    (normalize-space(
      child::span[ (@class = 'mrow-super') ] 
        / child::span[ (@class != 'begin-script')
                       and
                       (@class != 'end-script')
                     ]
     ) = '2')
  and `<su verbose not on op`>
]" >
   <xsl:copy>
      <xsl:apply-templates select="*|@*|text()|comment()" 
                           mode="squared" />
   </xsl:copy>
</xsl:template> 
>>>


\<su verbose not on op\><<<
not(
  child::span[ (@class = 'mrow-base') ] 
    / child::span[ not( @title = 'speech-extra' ) ]
                 [ position() = last() ]
    / self::* [ @class = 'mo-op' ]    
)
>>>




\<superscript into squared abd cube\><<<
<xsl:template match="*|@*|text()|comment()" 
                           mode="squared" >
   <xsl:copy>
     <xsl:choose>
        <xsl:when test=" @class = 'mrow-super' ">
           <xsl:apply-templates select="@*" />
           <span class="mo-op">
             <xsl:text> squared </xsl:text>
           </span>
        </xsl:when>  
        <xsl:otherwise>
           <xsl:apply-templates select="*|@*|text()|comment()" />
        </xsl:otherwise>
     </xsl:choose>
   </xsl:copy>
</xsl:template> 
>>>






\begin{verbatim}
<span class="msup">
  <span class="mrow-base">
    <span class="mo-op">cos</span>
  </span>
  <span class="mrow-super">
    <span class="begin-script"> superscript </span>
    <span class="mn">2</span>
    <span class="end-script"> baseline </span>
  </span>
</span>
\end{verbatim}




\<superscript into squared abd cube\><<<
<xsl:template match="span[
    (@class = 'msup') 
  and
    (normalize-space(
      child::span[ (@class = 'mrow-super') ] 
        / child::span[ (@class != 'begin-script')
                       and
                       (@class != 'end-script')
                     ]
     ) = '3')
  and `<su verbose not on op`>
]" >
   <xsl:copy>
      <xsl:apply-templates select="*|@*|text()|comment()" 
                           mode="cube" />
   </xsl:copy>
</xsl:template> 
>>>



\<superscript into squared abd cube\><<<
<xsl:template match="*|@*|text()|comment()" 
                           mode="cube" >
   <xsl:copy>
     <xsl:choose>
        <xsl:when test=" @class = 'mrow-super' ">
           <xsl:apply-templates select="@*" />
           <span class="mo-op">
             <xsl:text> cube </xsl:text>
           </span>
        </xsl:when>  
        <xsl:otherwise>
           <xsl:apply-templates select="*|@*|text()|comment()" />
        </xsl:otherwise>
     </xsl:choose>
   </xsl:copy>
</xsl:template> 
>>>


\<sub superscript 2 and 3 into verbose\><<<
<set name="m-subsup-2-3" >
  `<open xslt script`>
  `<subsup into sub squared and cube`> 
  `<close xslt script`>
</set>
<xslt name="." xml="." xsl="m-subsup-2-3" />
>>>





\<subsup into sub squared and cube\><<<
<xsl:template match="span[
    (@class = 'msubsup') 
  and
    (normalize-space(
      child::span[ (@class = 'mrow-super') ] 
        / child::span[ (@class != 'mid-script')
                       and
                       (@class != 'end-script')
                     ]
     ) = '2')
  and `<su verbose not on op`>
]" >
   <xsl:copy>
      <xsl:attribute name="class" >
         <xsl:text>msub</xsl:text>
      </xsl:attribute>
      <xsl:apply-templates select="*|text()|comment()" 
                           mode="sub-squared" />
   </xsl:copy>
</xsl:template> 
>>>



\<subsup into sub squared and cube\><<<
<xsl:template match="*|@*|text()|comment()" 
                           mode="sub-squared" >
   <xsl:copy>
     <xsl:choose>
        <xsl:when test=" @class = 'mrow-sub' ">
           <xsl:apply-templates select="*[
                       not( @class = 'end-script' )
                     ]
                           |@*|text()|comment()" />
           <xsl:apply-templates select="
               following-sibling::*[1] / *[
                        @class = 'end-script' 
                  ] " />
        </xsl:when>  
        <xsl:when test=" @class = 'mrow-super' ">
           <xsl:attribute name="class" >
               <xsl:text>squared-super</xsl:text>
           </xsl:attribute>
           <span class="mo-op">
             <xsl:text> squared </xsl:text>
           </span>
        </xsl:when>  
        <xsl:otherwise>
           <xsl:apply-templates select="*|@*|text()|comment()" />
        </xsl:otherwise>
     </xsl:choose>
   </xsl:copy>
</xsl:template> 
>>>


\<subsup into sub squared and cube\><<<
<xsl:template match="span[
    (@class = 'msubsup') 
  and
    (normalize-space(
      child::span[ (@class = 'mrow-super') ] 
        / child::span[ (@class != 'mid-script')
                       and
                       (@class != 'end-script')
                     ]
     ) = '3')
  and `<su verbose not on op`>
]" >
   <xsl:copy>
      <xsl:attribute name="class" >
         <xsl:text>msub</xsl:text>
      </xsl:attribute>
      <xsl:apply-templates select="*|text()|comment()" 
                           mode="sub-cube" />
   </xsl:copy>
</xsl:template> 
>>>



\<subsup into sub squared and cube\><<<
<xsl:template match="*|@*|text()|comment()" 
                           mode="sub-cube" >
   <xsl:copy>
     <xsl:choose>
        <xsl:when test=" @class = 'mrow-sub' ">
           <xsl:apply-templates select="*[
                       not( @class = 'end-script' )
                     ]
                           |@*|text()|comment()" />
           <xsl:apply-templates select="
               following-sibling::*[1] / *[
                        @class = 'end-script' 
                  ] " />
        </xsl:when>  
        <xsl:when test=" @class = 'mrow-super' ">
           <xsl:attribute name="class" >
               <xsl:text>cube-super</xsl:text>
           </xsl:attribute>
           <span class="mo-op">
             <xsl:text> cube </xsl:text>
           </span>
        </xsl:when>  
        <xsl:otherwise>
           <xsl:apply-templates select="*|@*|text()|comment()" />
        </xsl:otherwise>
     </xsl:choose>
   </xsl:copy>
</xsl:template> 
>>>



%%%%%%%%%%%%%
\subsection{Numeric Subscripts (Rule 77)}
%%%%%%%%%%%%%

\<compress numeric subscripts\><<<
  <set name="num-sub" >
     `<open xslt script`>
     `<num sub`> 
     `<close xslt script`>
  </set>
  <xslt name="." xml="." xsl="num-sub" />
>>>



\<num sub\><<<
<xsl:template match="span[
    (@class = 'msub')
  and
    (count( child::span[ @class = 'mrow-base' ] 
           / child::* ) = 1 )
  and not( ancestor::*[
      (@class = 'msub')
    or
      (@class = 'msup')
    or
      (@class = 'msubsup')
    ] )
  and
    not( child::span[ @class = 'mrow-sub' ] 
           / child::* [
                not( @title = 'speech-extra' )
              and
                not( @class = 'mn' )
              and
                not( 
                  (@class = 'mo-punc')
                  and
                  ( . = ',' )
                  and
                  preceding-sibling::*[1][ @class = 'mn' ]
                  and
                  following-sibling::*[1][ @class = 'mn' ]
                  and
                  following-sibling::*[2][ @class = 'mn' ]
                  and
                  following-sibling::*[3][ @class = 'mn' ]
                  and
                  (  not(following-sibling::*[4])
                     or
                     not(following-sibling::*[4][ @class = 'mn' ])
                  )
                )
              and
                not( 
                  (@class = 'mo-punc')
                  and
                  ( . = '.' )
                  and
                  following-sibling::*[1][ @class = 'mn' ]
                  and
                  not(
                    following-sibling::*[ 
                       (@class = 'mo-punc')
                     and
                       (. = '.')
                    ]
                  )
                )
          ]) 
]" >
  <xsl:copy>
     <xsl:apply-templates select="@*" />     
     <xsl:apply-templates select="*[1]" />
     <span class="mrow-sub">
        <span class="space" title="speech-extra">
           <xsl:text> </xsl:text> 
        </span>
        <xsl:apply-templates
           select="*[2] / *[ 
                    not(@title = 'speech-extra')  
                 and
                    not(
                      (@class = 'mo-punc')
                      and (. = ',')
                    )  
          ]" />
     </span>
  </xsl:copy>
</xsl:template> 
>>>

Emacspeak doesn't read fluently numbers with commas. For instance `10,000' is 
treated as `ten comma zero zero zero'.

\begin{verbatim}
<span class="msub">
  <span class="mrow-base">
    <span class="mi">x</span>
  </span>
  <span class="mrow-sub">
    <span class="begin-script" title="speech-extra"> subscript </span>
    <span class="mn">1</span>
    <span class="end-script" title="speech-extra"> baseline </span>
  </span>
</span>
\end{verbatim}

%%%%%%%%%%%%%
\subsection{Primes}
%%%%%%%%%%%%%

\<remove scrip indicators from primes\><<<
<xsl:template match="span[
    (@class = 'begin-script')
  and
    following-sibling::*[
         child::span / child::span[ 
            (@class = 'ch 2032') or (@class = 'ch 2033')
                                 or (@class = 'ch 2034')
    ]    ]
]" >
</xsl:template> 
>>>



\<remove scrip indicators from primes\><<<
<xsl:template match="span[
    (@class = 'end-script')
  and
    preceding-sibling::*[
         child::span / child::span[ 
            (@class = 'ch 2032') or (@class = 'ch 2033') 
                                 or (@class = 'ch 2034')
    ]    ]
]" >
</xsl:template> 
>>>



\begin{verbatim}
<span class="msup">
  <span class="mrow-base">
    <span class="mi">x</span>
  </span>
  <span class="mrow-super">
    <span class="begin-script"> superscript </span>
    <span class="mo-op">
      <span class="char">
        <span class="ch 2033">double prime</span>
      </span>
    </span>
    <span class="end-script"> baseline </span>
  </span>
</span>
\end{verbatim}

\<subsup prime\><<<
<set name="subsup-prime" >
   `<open xslt script`>
   `<compress subsup prime`> 
   `<close xslt script`>
</set>
<xslt name="." xml="." xsl="subsup-prime" />
>>>


\<compress subsup prime\><<<
<xsl:template match="span[ 
    (@class = 'msubsup')
  and
    (count(
        child::* [ @class='mrow-super' ]
       / child::span [ not(@title = 'speech-extra') ] ) = 1)
  and
    (count(
       child::* [ @class='mrow-super' ]
          / child::span [ not(@title = 'speech-extra') ] 
          / child::span) = 1)
  and
    child::* [ @class='mrow-super' ]
       / child::span [ not(@title = 'speech-extra') ] 
       / child::span[ @class='char' ]
       / child::span[
            (@class = 'ch 2032') or (@class = 'ch 2033') 
                                 or (@class = 'ch 2034') 
         ]  
]" >  
  <xsl:copy>
    <xsl:attribute name="class" >
       <xsl:text>msub</xsl:text>
    </xsl:attribute>
    <span class="mrow-base"> 
       <xsl:apply-templates select="
             *[@class = 'mrow-base'] / *
          " />    
       <xsl:apply-templates select="
             *[@class = 'mrow-super']
             / child::span [ not(@title = 'speech-extra') ] 
          " />    
    </span> 
    <xsl:apply-templates select="*[@class = 'mrow-sub']" />
  </xsl:copy>
</xsl:template> 
>>>



\begin{verbatim}
<span class="msubsup"> 
  <span class="mrow-base"> 
    <span class="mi">x</span> 
  </span> 
  <span class="mrow-sub"> 
    ......
  </span> 
  <span class="mrow-super"> 
    <span class="mid-script" title="speech-extra"> superscript </span> 
    <span class="mi"> 
      <span class="char" title="ch-verbose"> 
        <span class="ch 2032" title="ch-verbose">prime</span> 
      </span> 
    </span> 
  </span> 
</span> 
\end{verbatim}


%%%%%%%%%%%%%%%%%%
\section{Over and Under Limit Scripts}
%%%%%%%%%%%%%%%%%%


\<over and under scripts\><<<
<script element="span::limits-msub-msup" >
  <set name="smash" >
     `<open xslt script`>
     `<smash over and under scripts`>
     `<close xslt script`>
  </set>
  <xslt name="." xml="." xsl="smash" />
</script> 
>>>

\<smash over and under scripts\><<<
<xsl:template match="span[
       (@class = 'limits-msub-msup')
     and
       child::*[ (position() = 1) 
                 and (@class = 'limits-mrow-base')
                 and child::*[ (position() = 1) 
                         and (@class = 'limits-msub-msup')
       ]             ]
]" >
  <xsl:copy>
     <xsl:apply-templates select="@*" />
     <xsl:apply-templates select="
                   *[1]
                   / *[1] 
                   / *[ not(@class='limits-mrow-super') ]  " />
     <xsl:apply-templates select=" *[
                   preceding-sibling::* 
                 and
                   not(@class='limits-mrow-super') ]" />
     <xsl:apply-templates select="
                   *[1]
                   / *[1]
                   / *[@class='limits-mrow-super' ]  " />
     <xsl:apply-templates select=" *[
                   preceding-sibling::* 
                 and
                   (@class='limits-mrow-super') ]" />
  </xsl:copy>
</xsl:template> 
>>>


\<compress limit script\><<<
<xsl:template match="span[ @class = 'end-limits-script' ]" >
  <xsl:if test=" parent::*[ not(following-sibling::*) ] ">
    <xsl:copy>
       <xsl:apply-templates select=" @* " />
       <xsl:choose>
          <xsl:when test="  
                parent::*[ preceding-sibling::span[
                                  @class != 'limits-mrow-base'
                         ]  ]
            " >
            <xsl:text> end scripts </xsl:text>
          </xsl:when>
          <xsl:otherwise>
            <xsl:text> end script </xsl:text>
          </xsl:otherwise>
       </xsl:choose>
    </xsl:copy>
  </xsl:if>
</xsl:template> 
>>>


\<compress limit script\><<<
<xsl:template match="span[ @class = 'begin-limits-script' ]" >
    <xsl:copy>
       <xsl:apply-templates select=" @* " />
       <xsl:choose>
          <xsl:when test="  
                parent::*[ @class = 'limits-mrow-super'  ]
          " >
              <xsl:apply-templates 
                  select=" parent::* 
                           / preceding-sibling::*[1] " 
                  mode = "extra-over" />
          </xsl:when>
          <xsl:when test="  
                parent::*[ @class = 'limits-mrow-sub'  ]
          " >
              <xsl:apply-templates 
                  select=" parent::* 
                           / preceding-sibling::*[1] " 
                  mode = "extra-under" />
          </xsl:when>
       </xsl:choose>
       <xsl:apply-templates select="*|text()|comment()" />
    </xsl:copy>
</xsl:template> 
>>>



\<compress limit script\><<<
<xsl:template match="*" mode="extra-over" >
   <xsl:if   test = " self::span[ @class = 'limits-mrow-super' ] " >
     <xsl:text> over </xsl:text>
     <xsl:apply-templates select=" preceding-sibling::*[1] " 
                    mode = "extra-over" />
   </xsl:if>
</xsl:template> 
>>>


\<compress limit script\><<<
<xsl:template match="*" mode="extra-under" >
   <xsl:if   test = " self::span[ @class = 'limits-mrow-sub' ] " >
     <xsl:text> under </xsl:text>
     <xsl:apply-templates select=" preceding-sibling::*[1] " 
                    mode = "extra-under" />
   </xsl:if>
</xsl:template> 
>>>






%%%%%%%%%%%%%%%%%%
\section{Fractions}
%%%%%%%%%%%%%%%%%%

%%%%%%%%%%%%%
\subsection{Outline}
%%%%%%%%%%%%%



\<span frac elements\><<<
<script element="span::mfrac" >
  <set name="mfrac" >
     `<open xslt script`>
     `<frac templates`> 
     `<close xslt script`>
  </set>
  <xslt name="." xml="." xsl="mfrac" />
</script> 
>>>

\<frac templates\><<<
<xsl:template match="span[ @class = 'mfrac' ]" >
  <xsl:copy>
    <xsl:choose>
       `<constant fracs`>
       `<prepend continuos fractions`>
       `<tail continuos fractions`>
       <xsl:otherwise>
         <xsl:apply-templates select="*|@*|text()|comment()" />
       </xsl:otherwise>
    </xsl:choose>
  </xsl:copy>
</xsl:template> 
>>>

%%%%%%%%%%%%%
\subsection{Continuos Fractions}
%%%%%%%%%%%%%

%%%%%%%%%%%%%
\subsubsection{Get Three Bottom Levels}
%%%%%%%%%%%%%



\<tail continuos fractions\><<<
<xsl:when test="          `%check numeral numerator`%
   (translate(
      normalize-space(
      child::span[ @class = 'mrow-numerator' ]),
                              '0123456789','')= '')
   and `<check equality of numerators`>
   and `<check ops before two top fracs`>
">
  `<a,b := top 2 pre op values`>
  <xsl:choose>
     <xsl:when test="
         ( translate($a,'0123456789 ','') = '')
         and (normalize-space($a)=normalize-space($b)) 
         and starts-with( $c, normalize-space( $a )) 
         and starts-with(
               normalize-space(
                 substring-after( $c, normalize-space( $a )) )
               , 
               normalize-space(
                    child::span[ @class = 'mrow-enumerator' ] /
                    child::span[ @class = 'mfrac' ] /
                    preceding-sibling::*[1]                  )
             )
     " >
         <xsl:attribute name="class">
            <xsl:value-of select=" 'continuous-mfrac' " />
         </xsl:attribute>         
         <xsl:apply-templates select="*|text()|comment()" />
     </xsl:when>
     <xsl:otherwise>
         <xsl:apply-templates select="*|@*|text()|comment()" />
     </xsl:otherwise>
  </xsl:choose>
</xsl:when>
>>>


\<check equality of numerators\><<<
(  normalize-space(
   child::span[ @class = 'mrow-numerator' ])
  and
   normalize-space(
   child::span[ @class = 'mrow-enumerator' ] /
   child::span[ @class = 'mfrac' ] /
   child::span[ @class = 'mrow-numerator' ])
)
and
(  normalize-space(
   child::span[ @class = 'mrow-enumerator' ] /
   child::span[ @class = 'mfrac' ] /
   child::span[ @class = 'mrow-numerator' ])
  and
   normalize-space(
   child::span[ @class = 'mrow-enumerator' ] /
   child::span[ @class = 'mfrac' ] /
   child::span[ @class = 'mrow-enumerator' ] /
   child::span[ @class = 'mfrac' ] /
   child::span[ @class = 'mrow-numerator' ])
)
>>>



\<check ops before two top fracs\><<<
(  child::span[ @class = 'mrow-enumerator' ] /
   child::span[ @class = 'mfrac' ] /
   preceding-sibling::*[1][@class = 'mo-bin']
)
and  
(  normalize-space(
   child::span[ @class = 'mrow-enumerator' ] /
   child::span[ @class = 'mfrac' ] /
   preceding-sibling::*[1] )
   =
   normalize-space(
   child::span[ @class = 'mrow-enumerator' ] /
   child::span[ @class = 'mfrac' ] /
   child::span[ @class = 'mrow-enumerator' ] /
   child::span[ @class = 'mfrac' ] /
   preceding-sibling::*[1] )
)
>>>



\<a,b := top 2 pre op values\><<<
<xsl:variable name="a">
   <xsl:apply-templates select="
         child::span[ @class = 'mrow-enumerator' ] /
         child::span[ @class = 'mfrac' ] /
         preceding-sibling::*[2] 
   "  mode="enum-op" />  
</xsl:variable>
<xsl:variable name="b">
   <xsl:apply-templates select="
         child::span[ @class = 'mrow-enumerator' ] /
         child::span[ @class = 'mfrac' ] /
         child::span[ @class = 'mrow-enumerator' ] /
         child::span[ @class = 'mfrac' ] /
         preceding-sibling::*[2] 
   "  mode="enum-op" />  
</xsl:variable>
<xsl:variable name="c">
   <xsl:value-of select="
    normalize-space(
      child::span[ @class = 'mrow-enumerator' ] /
      child::span[ @class = 'mfrac' ] /
      child::span[ @class = 'mrow-enumerator' ] /
      child::span[ @class = 'mfrac' ] /
      child::span[ @class = 'mrow-enumerator' ] )
   "  />  
</xsl:variable>
>>>


\<frac templates\><<<
<xsl:template match="*" mode="enum-op">
   <xsl:if test="preceding-sibling::*" >
      <xsl:apply-templates select=" preceding-sibling::*[1] " />
   </xsl:if>
   <xsl:value-of select="." />
</xsl:template>
>>>




%%%%%%%%%%%%%
\subsubsection{Prepend Existing one}
%%%%%%%%%%%%%



\<prepend continuos fractions\><<<
<xsl:when test="
      (@class = 'mfrac')
    and
      child::span[ @class = 'mrow-enumerator' ]
        / child::span[ @class = 'continuous-mfrac' ]
    and
      ( normalize-space(
          child::span[ @class = 'mrow-numerator' ]
        )
        =
        normalize-space(
          child::span[ @class = 'mrow-enumerator' ]
           / child::span[ @class = 'continuous-mfrac' ]
           / child::span[ @class = 'mrow-numerator' ]  
        )
      ) 
    and `<check equality of op with cont frac`>
" >
  `<a,b := cont top 2 pre op values`>
  <xsl:choose>
     <xsl:when test="
         normalize-space($a)=normalize-space($b)
     " >
         <xsl:attribute name="class">
            <xsl:value-of select=" 'continuous-mfrac' " />
         </xsl:attribute>         
         <xsl:apply-templates select="*|text()|comment()" />
     </xsl:when>
     <xsl:otherwise>
         <xsl:apply-templates select="*|@*|text()|comment()" />
     </xsl:otherwise>
  </xsl:choose>
</xsl:when> 
>>>

\<check equality of op with cont frac\><<<
(
   normalize-space(
   child::span[ @class = 'mrow-enumerator' ] /
   child::span[ @class = 'mfrac' ] /
   preceding-sibling::*[1] )
   =
   normalize-space(
   child::span[ @class = 'mrow-enumerator' ] /
   child::span[ @class = 'mfrac' ] /
   child::span[ @class = 'mrow-enumerator' ] /
   child::span[ @class = 'continuous-mfrac' ] /
   preceding-sibling::*[1] )
)
>>>


\<a,b := cont top 2 pre op values\><<<
<xsl:variable name="a">
   <xsl:apply-templates select="
         child::span[ @class = 'mrow-enumerator' ] /
         child::span[ @class = 'mcontinuous-mfrac' ] /
         preceding-sibling::*[2] 
   "  mode="enum-op" />  
</xsl:variable>
<xsl:variable name="b">
   <xsl:apply-templates select="
         child::span[ @class = 'mrow-enumerator' ] /
         child::span[ @class = 'mcontinuous-mfrac' ] /
         child::span[ @class = 'mrow-enumerator' ] /
         child::span[ 
           (@class = 'mfrac') or (@class = 'mcontinuous-mfrac')
         ] /
         preceding-sibling::*[2] 
   "  mode="enum-op" />  
</xsl:variable>
>>>

%%%%%%%%%%%%%
\subsection{Word Fractions}
%%%%%%%%%%%%%



\<constant fracs\><<<
<xsl:when test=" 
   (string-length(
      normalize-space(child::span[ @class = 'mrow-numerator' ][1])
     ) = 1)
   and
   (string-length(
     normalize-space(child::span[ @class = 'mrow-enumerator' ][1])
     ) = 1)
">
   `<a := numerator; b := enumerator`>
   <xsl:choose>
      <xsl:when test=" 
           (translate($a,'123456789','') != '')
           or
           (translate($b,'123456789','') != '')
       " >
         <xsl:apply-templates select="*|@*|text()|comment()" />
      </xsl:when>
      <xsl:when test=" $a &lt; $b ">
         <xsl:attribute  name="class">
             <xsl:text>word-frac</xsl:text>
         </xsl:attribute>
         `<word numerator`>
         `<word enumerator`>
      </xsl:when>
      <xsl:otherwise>
         <xsl:apply-templates select="*|@*|text()|comment()" />
      </xsl:otherwise>
   </xsl:choose>    
</xsl:when>
>>>


\<a := numerator; b := enumerator\><<<
<xsl:variable name="a">
   <xsl:value-of select="
      normalize-space(child::span[ @class = 'mrow-numerator' ][1])
   " />
</xsl:variable>
<xsl:variable name="b">
   <xsl:value-of select="
      normalize-space(child::span[ @class = 'mrow-enumerator' ][1])
   " />
</xsl:variable>
>>>


\<word numerator\><<<
<xsl:choose>
   <xsl:when test=" $a = 1 "><xsl:text> one </xsl:text></xsl:when>
   <xsl:when test=" $a = 2 "><xsl:text> two </xsl:text></xsl:when>
   <xsl:when test=" $a = 3 "><xsl:text> three </xsl:text></xsl:when>
   <xsl:when test=" $a = 4 "><xsl:text> four </xsl:text></xsl:when>
   <xsl:when test=" $a = 5 "><xsl:text> five </xsl:text></xsl:when>
   <xsl:when test=" $a = 6 "><xsl:text> six </xsl:text></xsl:when>
   <xsl:when test=" $a = 7 "><xsl:text> seven </xsl:text></xsl:when>
   <xsl:when test=" $a = 8 "><xsl:text> eight </xsl:text></xsl:when>
   <xsl:when test=" $a = 9 "><xsl:text> nine </xsl:text></xsl:when>
</xsl:choose>
>>>


\<word enumerator\><<<
<xsl:choose>
   <xsl:when test=" $b = 2 "><xsl:text> half</xsl:text></xsl:when>
   <xsl:when test=" $b = 3 "><xsl:text> third</xsl:text></xsl:when>
   <xsl:when test=" $b = 4 "><xsl:text> fourth</xsl:text></xsl:when>
   <xsl:when test=" $b = 5 "><xsl:text> fifth</xsl:text></xsl:when>
   <xsl:when test=" $b = 6 "><xsl:text> sixth</xsl:text></xsl:when>
   <xsl:when test=" $b = 7 "><xsl:text> seventh</xsl:text></xsl:when>
   <xsl:when test=" $b = 8 "><xsl:text> eighth</xsl:text></xsl:when>
   <xsl:when test=" $b = 9 "><xsl:text> nineth</xsl:text></xsl:when>
</xsl:choose>
<xsl:if test=" $a &gt; 1 "><xsl:text>s</xsl:text></xsl:if>
<xsl:text> </xsl:text>
>>>


%%%%%%%%%%%%%
\subsection{Prefix `and' Connectors}
%%%%%%%%%%%%%

\<fraction 'and' prefix\><<<
<xsl:template match="span[
   ((@class = 'mfrac') and 
                       (translate(
                          concat(
                            span[ (@class = 'mrow-numerator')],
                            span[ (@class = 'mrow-enumerator')] 
                          )  ,'0123456789','') = '')
                       and
                       not(descendant::*/descendant::*/descendant::*)
    or 
    (@class = 'word-frac'))
   and 
   preceding-sibling::*[1]
       / self::span[ @class = 'mn']
 ]" >
  <xsl:text> and </xsl:text>
  <xsl:copy>
    <xsl:apply-templates select="*|@*|text()|comment()" />
  </xsl:copy>
</xsl:template> 
>>>

%%%%%%%%%%%%%
\subsection{Hyper Complex Fractions}
%%%%%%%%%%%%%


\<set levels for hyper complex fracs\><<<
<dom name="." xml="." method="fracLevel" class="tex4ht.HtSpk" />
`<remove xml declaration`>
>>>



\<static void fracLevel(dom)\><<<
public static void fracLevel(Node dom) {
   setFracLevel(dom.getFirstChild(), 0);
}
private static int setFracLevel(Node node, int cont) {
  int level = 0;
  String clName = null;
  if (node.hasChildNodes()) {
    if (node.hasAttributes()) {
      Node cl = node.getAttributes().getNamedItem("class");
      if (cl != null) { clName = cl.getNodeValue(); }
    }
    `<count levels inherited from children`>
    if( clName != null ){
      `<block on sub and super scripts`>
      `<deal with continuou fracs`>
      if (clName.equals("mfrac")) {
        if( cont > 0 ){
          `<remove end of nested continuous frac`> 
        } else if( level > 0 ){
          `<set extra levels for frac`>
        }
        level++;
  } } }
  return level;
}
>>>


\<count levels inherited from children\><<<
NodeList children = node.getChildNodes();
int max = 0;
for (int i = 0; i < children.getLength(); i++) {
   Node child = children.item(i);
   if (child.getNodeType() == Node.ELEMENT_NODE) {
      int d = setFracLevel(child, 
           (clName != null) &&
            clName.equals("continuous-mfrac")? 
            2 : 
            ((clName != null) &&
              clName.equals("continuous-mfrac")?
                (cont-1) : cont)
        );
      if (d > max) { max = d; }
}  }
level += max;
>>>




The `cont' parameter is for determining whether the parent and the
grandparent are frac elements marked as continuous.


\<block on sub and super scripts\><<<
if( clName.equals("msub") || clName.equals("msup") ||
    clName.equals("msubsup") 
) {
   return 0;
}
>>>


\<deal with continuou fracs\><<<
if( clName.equals("continuous-mfrac") ) {
   if( cont > 0 ){   
     `<remove end of nested continuous frac`>
   } else { `<set continuous frac`> } `%root of continuous chain`%
   return 0;
}
>>>



\<set extra levels for frac\><<<
for (int i = 0; i < children.getLength(); i++) {
  Node child = children.item(i);
  if (child.getNodeType() == Node.ELEMENT_NODE) {
    Node cls = child.getAttributes()
                    .getNamedItem("class");
    if (cls != null) {
      String clsName = cls.getNodeValue();
      if (clsName.equals("begin-end")) {
         child = child.getFirstChild();
         String s = child.getNodeValue();
         String bg = "", ov = "", en = "";
         for(int j=0; j<level; j++){ 
            bg += " begin "; ov += " over "; en += " end ";
         }
         s = s.replaceFirst("begin", bg + "begin");
         s = s.replaceFirst("over", ov + "over");
         s = s.replaceFirst("end", en + "end");
         ((org.w3c.dom.Text) child).setData(s);
} } } }
>>>


\<set continuous frac\><<<
for (int i = 0; i < children.getLength(); i++) {
  Node child = children.item(i);
  if (child.getNodeType() == Node.ELEMENT_NODE) {
    Node cls = child.getAttributes()
                   .getNamedItem("class");
    if (cls != null) {
       String clsName = cls.getNodeValue();
       if ( clsName.equals("begin-end")) {
          child = child.getFirstChild();
          String s = child.getNodeValue();
          s = s.replaceFirst("begin", "begin continued");
          s = s.replaceFirst("end", "end continued");
          ((org.w3c.dom.Text) child).setData(s);
} } } }
>>>

\<remove end of nested continuous frac\><<<
Node child = node.getLastChild();
if (child.getNodeType() == Node.ELEMENT_NODE) {
   Node cls = child.getAttributes() .getNamedItem("class");
   if (cls != null) {
      String clsName = cls.getNodeValue();
      if ( clsName.equals("begin-end")) {
         node.removeChild( child  );
}  }  }
>>>




%%%%%%%%%%%%%
\subsection{Set Levels on Roots}
%%%%%%%%%%%%%

\<set levels for roots\><<<
<dom name="." xml="." method="rootLevel" class="tex4ht.HtSpk" />
`<remove xml declaration`>
>>>

\<static void rootLevel(dom)\><<<
public static void rootLevel(Node dom) {
   setRootLevel(dom.getFirstChild());
}
private static int setRootLevel( Node node ){
  int level = 0;
  String clName = null;
  if (node.hasChildNodes()) {
    if (node.hasAttributes()) {
      Node cl = node.getAttributes().getNamedItem("class");
      if (cl != null) { clName = cl.getNodeValue(); }
    }
    `<count root levels inherited from children`>
    if( clName != null ){
      `<block for roots`>
      if( clName.equals("msqrt") || clName.equals("root") ){
        `<set extra levels for roots`>
        level++;
  } } }
  return level;
}
>>>


\<count root levels inherited from children\><<<
NodeList children = node.getChildNodes();
int max = 0;
for (int i = 0; i < children.getLength(); i++) {
  Node child = children.item(i);
  if (child.getNodeType() == Node.ELEMENT_NODE) {
    int d = setRootLevel(child);
    if( d > max ){ max = d; }
} }
level += max;
>>>


\<block for roots\><<<
if( clName.equals("msub") || clName.equals("msup") ||
    clName.equals("msubsup") 
) {
   return 0;
}
>>>




\<set extra levels for roots\><<<
for (int i = 0; i < children.getLength(); i++) {
  Node child = children.item(i);
  if (child.getNodeType() == Node.ELEMENT_NODE) {
    Node cls = child.getAttributes()
                    .getNamedItem("class");
    if (cls != null) {
      String clsName = cls.getNodeValue();
      if( clsName.equals("begin-root") 
          || clsName.equals("mid-root") 
          || clsName.equals("end-root") 
      ){
         child = child.getFirstChild();
         String s = child.getNodeValue();
         String nested = "";
         for(int j=0; j<level; j++){ 
            nested += " nested ";
         }
         ((org.w3c.dom.Text) child).setData( nested + s);
} } } }
>>>



%%%%%%%%%%%%%%%%%%
\section{Odd Ends}
%%%%%%%%%%%%%%%%%%

%%%%%%%%%%%%%
\subsection{Remove Empty Array Cells}
%%%%%%%%%%%%%

Empty array celles at end of rows can make it more difficult to 
detect deletable baseline indicators.



\<remove multline eqnum cell\><<<
<script element="div::tr" >
  <set name="bold" >
     `<open xslt script`>
     `<remove empty cells from rows`> 
     `<close xslt script`>
  </set>
  <xslt name="." xml="." xsl="bold" />
</script> 
>>>

\<remove empty cells from rows\><<<
<xsl:template match="div[ 
    parent::div[ @class = 'tr' ]
    and ( normalize-space(.) = '' )
    and not( normalize-space(following-sibling::*) != '' )
]" >
</xsl:template> 
>>>





%%%%%%%%%%%%%
\subsection{'minus' into 'negative'}
%%%%%%%%%%%%%



\<'minus' into 'negative'\><<<
<xsl:template match="span[
    (@class = 'mo-bin')
  and
    (   preceding-sibling::*[
           (position()=1) 
           and 
           ( (@title='speech-extra') 
             or (@class='mo-bin') 
             or (@class='mo-rel')  )
        ]
        and 
        (
           following-sibling::*[ (@class='mn') or (@class='mi') ]
          or
           (count(following-sibling::*[
               not(@title = 'speech-extra')
            ]) = 1)
        )
      or
        not(preceding-sibling::*)
    )
  and
    (normalize-space(.)='minus')
]" >
  <xsl:copy>
    <xsl:attribute name="class">
       <xsl:text>mo-unary</xsl:text>
    </xsl:attribute>
    <xsl:apply-templates select="*|text()|comment()" 
                         mode="minus-neg" />
  </xsl:copy>
</xsl:template> 
>>>


\<'minus' into 'negative'\><<<
<xsl:template match="*|@*|text()|comment()" mode="minus-neg" >
  <xsl:copy>
    <xsl:apply-templates select="*|@*|text()|comment()" 
                         mode="minus-neg" />
  </xsl:copy>
</xsl:template> 
>>>

\begin{verbatim}
<span class="begin-script"> subscript </span>
<span class="mo-bin">
  <span class="char">
    <span class="ch 2212">minus</span>
  </span>
</Span>
<span class="mn">2</span>
\end{verbatim}




\<'minus' into 'negative'\><<<
<xsl:template match="text()" mode="minus-neg" >
  <xsl:choose>
    <xsl:when test=" . = 'minus' " >
      <xsl:text>negative</xsl:text>
    </xsl:when>
    <xsl:otherwise>
      <xsl:value-of select="." />
    </xsl:otherwise>
  </xsl:choose>
</xsl:template> 
>>>

%%%%%%%%%%%%%
\subsection{Short-Cuts for Modifiers}
%%%%%%%%%%%%%

\<short cut modifiers\><<<
<script element="span::munder-underline" >
  <set name="munder" >
     `<open xslt script`>
     `<get content template`>
     `<under modifier templates`> 
     `<close xslt script`>
  </set>
  <xslt name="." xml="." xsl="munder" />
</script> 
>>>




\<short cut modifiers\><<<
<script element="span::mover-overline" >
  <set name="mover" >
     `<open xslt script`>
     `<get content template`>
     `<over modifier templates`> 
     `<close xslt script`>
  </set>
  <xslt name="." xml="." xsl="mover" />
</script> 
>>>









\<under modifier templates\><<<
<xsl:template match="span[
    (@class = 'munder-underline')
   and
    child::span[ 
       (@class = 'mo-0332')
       and
       descendant::span[ @class = 'mi' ]
   ]
]" >
  <xsl:copy>
    <xsl:apply-templates select="@*" />
    <xsl:variable name="content">
       <xsl:apply-templates select="*" mode="content" />
    </xsl:variable>
    <xsl:choose>
       <xsl:when test=" 
          string-length( normalize-space( $content )) = 1
       " >       
           <xsl:apply-templates
              select=" *[ @class != 'begin-end' ] " />
           <span class="begin-end" title="speech-extra" > 
              <xsl:text> under bar </xsl:text>
           </span>
       </xsl:when>
       <xsl:otherwise>
          <xsl:apply-templates select="*|text()|comment()" />
       </xsl:otherwise>
    </xsl:choose>
  </xsl:copy>
</xsl:template> 
>>>








\<over modifier templates\><<<
<xsl:template match="span[
    (@class = 'mover-overline')
   and
    child::span[ 
       (@class = 'mo-00AF')
       and
       descendant::span[ @class = 'mi' ]
   ]
]" >
  <xsl:copy>
    <xsl:apply-templates select="@*" />
    <xsl:variable name="content">
       <xsl:apply-templates select="*" mode="content" />
    </xsl:variable>
    <xsl:choose>
       <xsl:when test=" 
          string-length( normalize-space( $content )) = 1
       " >       
           <xsl:apply-templates
              select=" *[ @class != 'begin-end' ] " />
           <span class="begin-end" title="speech-extra" > 
              <xsl:text> over bar </xsl:text>
           </span>
       </xsl:when>
       <xsl:otherwise>
          <xsl:apply-templates select="*|text()|comment()" />
       </xsl:otherwise>
    </xsl:choose>
  </xsl:copy>
</xsl:template> 
>>>



\begin{verbatim}
<span class="mover-overline">
  <span class="begin-end" title="speech-extra"> modified above </span>
  <span class="mo-00AF">
    <span class="mathvariant-bold">
      <span title="speech-extra" class="begin-end"> bold </span>
      <span class="mi">
          <span title="speech-extra" 
                class="capital-description"> capital </span>
          Z
      </span>
    </span>
  </span>
  <span class="begin-end" title="speech-extra"> with bar </span>
</span>
\end{verbatim}



\begin{verbatim}
<span class="munder-underline">
  <span class="begin-end" title="speech-extra" > modified under </span>
  <span class="mo-0332">
    <span class="mi">x</span>
  </span>
  <span class="begin-end" title="speech-extra" > with bar </span>
</span>
\end{verbatim}

%%%%%%%%%%%%%
\subsection{Font Decorations}
%%%%%%%%%%%%%





\<bold math\><<<
<script element="span::mathvariant-bold" >
  <set name="bold" >
     `<open xslt script`>
     `<get content template`>
     `<math bold templates`> 
     `<close xslt script`>
  </set>
  <xslt name="." xml="." xsl="bold" />
</script> 
>>>



\<math bold templates\><<<
<xsl:template match="span[ @class = 'mathvariant-bold' ]" >
  <xsl:copy>
    <xsl:apply-templates select="@*" />
    <xsl:variable name="content">
       <xsl:apply-templates select="*" mode="content" />
    </xsl:variable>
    <xsl:choose>
       <xsl:when test=" 
          string-length( normalize-space( $content )) = 1
       " >
          <span class="begin-end" title="speech-extra" > 
             <xsl:text> bold </xsl:text>
          </span>
          <xsl:apply-templates select="*|text()|comment()" />
       </xsl:when>
       <xsl:otherwise>
          <span class="begin-end" title="speech-extra" > 
             <xsl:text> begin bold </xsl:text>
          </span>
          <xsl:apply-templates select="*|text()|comment()" />
          <span class="begin-end" title="speech-extra" > 
             <xsl:text> end bold </xsl:text>
          </span>
       </xsl:otherwise>
    </xsl:choose>
  </xsl:copy>
</xsl:template> 
>>>


%%%%%%%%%%%%%
\section{Eliminate Inline Math Narrative}
%%%%%%%%%%%%%


%%%%%%%%%%%%%
\subsection{Simple Sub-Sup (Core Content of Length One)}
%%%%%%%%%%%%%




\<eliminate inline math narrative\><<<
<xsl:template match="span[
    (@class = 'inline-math')
  and
    (count( `<math content element`> ) = 1)
]" >
  <xsl:copy>
    <xsl:variable name="content">
       <xsl:apply-templates
           select="`<math content element`>"
             mode="content" />
    </xsl:variable>
    <xsl:choose>
       <xsl:when test=" 
          string-length( normalize-space( $content )) = 1
       " >
          <xsl:attribute name="class">
             <xsl:text>semi-math</xsl:text>
          </xsl:attribute>
          <xsl:apply-templates select="`<math content element`>" />
       </xsl:when>
       `<simple sub or sup`>
       <xsl:otherwise>
          <xsl:apply-templates select="*|@*|comment()|text()" />
       </xsl:otherwise>
    </xsl:choose>
  </xsl:copy>
</xsl:template> 
>>>


\<math content element\><<<
child::*[ not(@title) or (@title != 'speech-extra') ]
>>>


\<simple sub or sup\><<<
<xsl:when test="  child::*[
     (position() = 2)
   and
     ((@class = 'msub') or (@class = 'msup') or (@class = 'msubsup'))
]" >
    <xsl:variable name="content">
       <xsl:apply-templates select="child::*[2] / child::*[
                                       @class = 'mrow-base' ]" 
                            mode="content" />
    </xsl:variable>
    <xsl:choose>
       <xsl:when test=" 
          string-length( normalize-space( $content )) = 1
       " >
          <xsl:attribute name="class">
             <xsl:text>semi-math</xsl:text>
          </xsl:attribute>
          <xsl:apply-templates select="*[2]" />
`%
          <span class="end-script" title="speech-extra">
             <xsl:text> baseline </xsl:text>
          </span> 
`%
      </xsl:when>
       <xsl:otherwise>
          <xsl:apply-templates select="*|@*|comment()|text()" />
       </xsl:otherwise>
    </xsl:choose>
</xsl:when>
>>>


\begin{verbatim}
<span class="inline-math">
  <span class="msub">
    <span class="mrow-base">
      <span class="mi">C</span>
    </span>
    <span class="mrow-sub">
      <span class="mi">i</span>
    </span>
  </span>
</span>
\end{verbatim}




%%%%%%%%%%%%%
\subsection{Unary Op on Core Content of Length One}
%%%%%%%%%%%%%

The `mo-unary' is established in the first pass over inline-math,
so we need to wait for the second pass with the following.


\<eliminate inline math narrative 2\><<<
<xsl:template match="span[
    (@class = 'inline-math')
  and
    (count( `<math content element`> ) = 2)
  and
    child::span[ 
        (@class = 'mo-unary')
      and
        following-sibling::*[1]
        / descendant::span[ @class = 'mi' ]
    ]    
]" >
  <xsl:copy>
    <xsl:variable name="content">
       <xsl:apply-templates
           select="child::*[ 
               (not(@title) or (@title != 'speech-extra'))
               and not( @class = 'mo-unary' )
             ]"
             mode="content" />
    </xsl:variable>
    <xsl:choose>
       <xsl:when test=" 
          string-length( normalize-space( $content )) = 1
       " >
          <xsl:attribute name="class">
             <xsl:text>semi-math</xsl:text>
          </xsl:attribute>
          <xsl:apply-templates select="`<math content element`>" />
       </xsl:when>
       <xsl:otherwise>
          <xsl:apply-templates select="*|@*|comment()|text()" />
       </xsl:otherwise>
    </xsl:choose>
  </xsl:copy>
</xsl:template> 
>>>



\begin{verbatim}
<span class="inline-math">
  <span class="begin-math" title="speech-extra"> begin math </span>
  <span name="mo-unary">
    <span class="char" title="ch-verbose">
      <span class="ch 2212" title="ch-verbose">negative</span>
    </span>
  </span>
  <span class="mathvariant-bold">
    <span title="speech-extra" class="begin-end"> bold </span>
    <span title="speech-extra" class="space"><!---->          </span>
    <span class="mi">
       <span title="speech-extra" class="capital-description"> 
         capital
       </span>
       A
    </span>
  </span>
  <span class="end-math" title="speech-extra">end math</span>
</span>
\end{verbatim}

%%%%%%%%%%%%%%%%%%
\section{Empty Elements}
%%%%%%%%%%%%%%%%%%


%%%%%%%%%%%%%
\subsection{Set for W3}
%%%%%%%%%%%%%



\<set empty elements for the w3 browser\><<<
<set name="empty-el" >
   `<open xslt script`>
   `<tags for empty templates`> 
   `<close xslt script`>
</set>
<xslt name="." xml="." xsl="empty-el" />
>>>

\<tags for empty templates\><<<
<xsl:template match="*[ not(child::*) ]" >
  <xsl:copy>
    <xsl:apply-templates select="@*|comment()|text()" />
    <xsl:if test=" normalize-space(.) = '' " >      
       <xsl:comment>`<comment`></xsl:comment>
    </xsl:if>
  </xsl:copy>
</xsl:template> 
>>>

Note: Java 5 complains when comments contain just white spaced.


\<comment\><<<
.>>>

%%%%%%%%%%%%%
\subsection{Remove Split Arrays}
%%%%%%%%%%%%%

\<remove empty split entries\><<<
<script element="div::split-side" >
  <set name="clean-split" >
     `<open xslt script`>
     `<get content template`>
     `<clean math split`> 
     `<close xslt script`>
  </set>
  <xslt name="." xml="." xsl="clean-split" />
</script> 
>>>


\<clean math split\><<<
<xsl:template match=" div[ @class='split-side' ] 
" >
    <xsl:variable name="content">
       <xsl:apply-templates select="*" mode="content" />
    </xsl:variable>
    <xsl:if test=" 
       string-length( normalize-space( $content )) != 0
    " >       
       <xsl:copy>
          <xsl:apply-templates select=" *|@*|text()|comment() " />
       </xsl:copy>
    </xsl:if>
</xsl:template> 
>>>


%%%%%%%%%%%%%%%%%%
\section{Spaces around Math Identifiers}
%%%%%%%%%%%%%%%%%%

The following is to cause a pause.  For instance, between the
variables in \verb+<mi>i</mi><mi>j</mi>+.


\<insert pre mi spaces\><<<
<xsl:template match="span[ @class = 'mi' ]" >
  <span class="space" title="speech-extra">
     <xsl:text> </xsl:text> 
  </span>
  <xsl:copy>
     <xsl:apply-templates select="*|@*|text()|comment()" />
  </xsl:copy>
</xsl:template>   
>>>



%%%%%%%%%%%%%%%%%%
\section{Prose}
%%%%%%%%%%%%%%%%%%

%%%%%%%%%%%%%
\subsection{Tables}
%%%%%%%%%%%%%

\<measure tablesREMOVE\><<<
<script element="div::table" >
  <set name="rows" >
     `<open xslt script`>
     `<record number of rows`> 
     `<close xslt script`>
  </set>
  <xslt name="." xml="." xsl="rows" />
</script> 
>>>


\<record number of rowsREMOVE\><<<
<xsl:template match=" 
   div[ (@class='table') 
        and 
        ((@title='tabular') or (@title='array'))
   ] 
" >
   <xsl:copy>
     <xsl:apply-templates select="@*" />
     <div class="begin-end" title="speech-extra"> 
        <xsl:value-of select=" 
           concat( child::*[1] /self::div[
             (@class = 'begin-end') and (@title = 'speech-extra')
                   ],
                   ' with ',
                   count(child::*) - 2 ,
                   ' rows '
           ) " />
     </div>
     <xsl:apply-templates select=" *[position() &gt; 1]
                                  | @* | text() | comment() " />
   </xsl:copy>
</xsl:template> 
>>>





%%%%%%%%%%%%%
\subsection{New Theorems}
%%%%%%%%%%%%%

\<boundaries on theorems\><<<
<script element="div::newtheorem" >
  <set name="newtheorem" >
     `<open xslt script`>
     `<annotate bounderies of theorems`> 
     `<tags for empty templates`>
     `<close xslt script`>
  </set>
  <xslt name="." xml="." xsl="newtheorem" />
</script> 
>>>


\<annotate bounderies of theorems\><<<
<xsl:template match=" 
    div[   (@class='newtheorem') 
         and
           child::*[1] / child::span[ @class = 'theorem-head' ]
    ]
" >
   <xsl:copy>
     <xsl:apply-templates select="*|@*|text()|comment()" />
     <div class="begin-end" title="speech-extra"> 
        <xsl:value-of select=" 
           concat( ' end ',
                   string( child::*[1] / 
                           child::span[ @class = 'theorem-head' ] )
           ) " />
     </div>
   </xsl:copy>
</xsl:template> 
>>>









%%%%%%%%%%%%%%%%%%
\section{Shared}
%%%%%%%%%%%%%%%%%%



\<open xslt script\><<<
<![CDATA[ 
   <xsl:stylesheet version="1.0"
      xmlns:xsl="http://www.w3.org/1999/XSL/Transform"
   >
      <xsl:output omit-xml-declaration = "yes" />
>>>

\<close xslt script\><<<
      <xsl:template match="*|@*|text()|comment()" >
        <xsl:copy>
          <xsl:apply-templates select="*|@*|text()|comment()" />
        </xsl:copy>
      </xsl:template>
   </xsl:stylesheet> 
]]>
>>>


\<get content template\><<<
<xsl:template match="*" mode="content" >
  <xsl:choose>
     <xsl:when test=" @class = 'char' " >   
       <xsl:text>x</xsl:text>
     </xsl:when>
     <xsl:when test=" not( 
            (@title = 'speech-extra') or (@class = 'accent-char')
         ) " >
       <xsl:apply-templates select="*|text()" mode="content" />
     </xsl:when>
  </xsl:choose>
</xsl:template> 
>>>


%%%%%%%%%%%%%%%%%%
\section{To Do}
%%%%%%%%%%%%%%%%%%

\begin{itemize}
\item
Left subscripts and tensors.
\end{itemize}


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\AtEndDocument{\Needs{%
    "cd /home/4/gurari/xtpipes.dir
     ;  
     jar cf tex4ht.jar *
     ;
     mv tex4ht.jar /home/4/gurari/tex4ht.dir/texmf/tex4ht/bin/. 
     ;
     cp /home/4/gurari/xtpipes.dir/xtpipes/lib/* 
        /home/4/gurari/tex4ht.dir/texmf/tex4ht/xtpipes/.
"}}




\end{document}





